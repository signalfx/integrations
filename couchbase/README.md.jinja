{% import "macros.jinja" as macros %}

{% if target == "docs" -%}
# ![](../../_images/images-integrations/integrations-reference/couchbase/integrations_couchbase.png) Couchbase

- [Overview](#overview)
- [Setup](#setup)
- [Built-in Content](#built-in-content)
- [Usage](#usage)
- [Metrics](#metrics)

{%- endif %}

## OVERVIEW

This integration consists primarily of the Smart Agent monitor `collectd/couchbase`.
Below is an overview of that monitor.

### Smart Agent Monitor

This is a Smart Agent monitor for [Couchbase](https://www.couchbase.com/) that uses the [Couchbase collectd Python plugin](https://github.com/signalfx/collectd-couchbase) that you configure to collect metrics from Couchbase server instances.

For general information on how to monitor Couchbase, see <a target="_blank"
href="http://blog.couchbase.com/monitoring-couchbase-cluster">Couchbase
Monitoring</a> and <a target="_blank"
href="http://developer.couchbase.com/documentation/server/4.0/monitoring/monitoring-rest.html">Monitor
using the REST API</a>.

### Creating a Couchbase user for collectd

If you're monitoring a secured Couchbase deployment, it is a good practice to create a Couchbase user with minimal read-only roles, as follows:

```
db.createUser( {
  user: "collectd",
  pwd: "collectd",
  roles: [ { role: "readAnyDatabase", db: "admin" }, { role: "clusterMonitor", db: "admin" } ]
});
```

## SETUP

#### Requirements

* SignalFx Smart Agent 2.0 or higher
* Couchbase 3.0 or higher

### Configuration

Couchbase provides Role-Based Access Control (RBAC) to restrict system access. A Couchbase role permits one or more resources to be accessed according to defined privileges. You specify roles as follows:

```
db.createUser( {
  user: "collectd",
  pwd: "collectd",
  roles: [ { role: "readAnyDatabase", db: "admin" }, { role: "clusterMonitor", db: "admin" } ]
});
```

## SETUP

#### Requirements

* SignalFx Smart Agent 2.0 or higher
* Couchbase 3.0 or higher

### Configuration

To activate this monitor in the Smart Agent, add the following to your agent config:

```
monitors:  # All monitor config goes under this key
 - type: collectd/couchbase
   ...  # Additional config
```

**For a list of monitor options that are common to all monitors, see [Common
Configuration](https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/../monitor-config.md#common-configuration).**


| Config option | Required | Type | Description |
| --- | --- | --- | --- |
| `pythonBinary` | no | `string` | Path to a python binary that should be used to execute the Python code. If not set, a built-in runtime will be used.  Can include arguments to the binary as well. |
| `host` | **yes** | `string` |  |
| `port` | **yes** | `integer` |  |
| `collectTarget` | **yes** | `string` | Define what this Module block will monitor: "NODE", for a Couchbase node, or "BUCKET" for a Couchbase bucket. |
| `collectBucket` | no | `string` | If CollectTarget is "BUCKET", CollectBucket specifies the name of the bucket that this will monitor. |
| `clusterName` | no | `string` | Name of this Couchbase cluster. (**default**:"default") |
| `collectMode` | no | `string` | Change to "detailed" to collect all available metrics from Couchbase stats API. Defaults to "default", collecting a curated set that works well with SignalFx. |
| `username` | no | `string` | Username to authenticate with |
| `password` | no | `string` | Password to authenticate with |

{% if target == "tile" -%}
## BUILT-IN CONTENT

### Features

### Built-in dashboards

- **Couchbase Clusters**: Overview of data from all Couchbase clusters reporting.

  [<img src='./img/dashboard_couchbase_clusters.png' width=200px>](./img/dashboard_couchbase_clusters.png)

- **Couchbase Nodes**: Overview of all data from Couchbase nodes.

  [<img src='./img/dashboard_couchbase_nodes.png' width=200px>](./img/dashboard_couchbase_nodes.png)

- **Couchbase Node**: Focus on a single Couchbase node.

  [<img src='./img/dashboard_couchbase_node.png' width=200px>](./img/dashboard_couchbase_node.png)

- **Couchbase Buckets**: Performance and activity of Couchbase buckets.

  [<img src='./img/dashboard_couchbase_buckets.png' width=200px>](./img/dashboard_couchbase_buckets.png)

- **Couchbase Bucket**: Focus on a single Couchbase bucket.

  [<img src='./img/dashboard_couchbase_bucket.png' width=200px>](./img/dashboard_couchbase_bucket.png)
{%- endif %}

## USAGE

The following screen captures of dashboards created for this plugin by SignalFx illustrate the metrics generated by this plugin.

For general reference on how to monitor Couchbase, see <a target="_blank" href="http://blog.couchbase.com/monitoring-couchbase-cluster">Couchbase Monitoring</a> and <a target="_blank" href="http://developer.couchbase.com/documentation/server/4.0/monitoring/monitoring-rest.html">Monitor using the REST API</a>.

**Note on bucket metrics**

This plugin generates some metrics about the bucket's performance across the cluster, and some metrics about the bucket's performance per node.

Metrics beginning with `gauge.bucket.basic.​*` and `gauge.bucket.quota.*`​ are reported once per cluster. All other bucket metrics (`gauge.bucket.*`) are reported by every node that hosts that bucket. To analyze bucket performance for the entire bucket, apply functions like `sum` or `mean` to group node-level metrics together by bucket.

**Monitoring a Couchbase cluster**

On the Couchbase Nodes overview dashboard, you can see at a glance the status of the nodes and buckets in a given cluster. Nodes in the cluster should show balanced activity. Buckets in the cluster should each have a portion of memory remaining free.

![Couchbase - Nodes and buckets in a cluster](././img/nodes_and_buckets_snapshot.png)

*This cluster's three nodes have roughly the same number of gets per second, and its two buckets have plenty of headroom.*

This dashboard also includes a percentile distribution of CPU utilization per node, enabling quick identification of unusually hot nodes, meaning those at > 80% capacity. This chart shows minimum, 10th percentile, median (50th percentile), 90th percentile, and maximum CPU utilization for each node in the cluster.

![Nodes CPU distribution](././img/nodes_cpu.png)

*This cluster's CPU utilization distribution shows only a small amount of variation in utilization, suggesting that each of the nodes is using about the same amount.*

**Monitoring a Couchbase node**

Zooming in to an individual node shows that node's activity, cache performance, and compute resource usage.

![Node overview](././img/node.png)

*This node is lightly loaded. To compare its activity to other nodes in this cluster, use the Couchbase Nodes dashboard above.*

We can check the node's cache performance using a graph that shows the number of gets per second in yellow, overlaid on the number of cache hits in blue. The ratio between gets and cache hits is computed as "hit ratio" and is shown as a dotted line. When every get request results in a cache hit, the graph is green and the dotted line remains high. When there are fewer cache hits than gets, the graph shows yellow areas and the dotted line drops.

![Gets and hits](././img/node_gets_and_hits.png)

*This lightly-loaded node has a 100% cache hit ratio: it can serve every get request that it receives from memory.*

**Monitoring Couchbase buckets**

The Couchbase Buckets overview shows activity for all buckets being monitored.

![Buckets overview](././img/buckets_activity.png)

*The buckets in this cluster happen to have about the same number of items and are serving about the same number of operations per second.*

**Monitoring a single Couchbase bucket**

Selecting a particular bucket to show on the Couchbase Bucket dashboard enables you to monitor details of that bucket's performance.

Resident items ratio and cache miss rate are inversely related: as the ratio of items in this bucket that are resident in memory drops, the number of get requests that require a fetch from disk will increase.

![Bucket cache performance](././img/bucket_cache_miss_rate.png)

*This bucket has a 100% resident items ratio: all of the items that it contains can be served from memory, instead of disk.*

The performance of Couchbase buckets is bound by memory. When memory is exhausted, new items can be stored only by ejecting old items. An attempt to store a new item in a bucket with insufficient memory headroom produces an out-of-memory error: either a "temp" error (an old item will be ejected, try again) or a "non-temp" error (this item cannot be stored at all). Any out-of-memory error is cause for concern.

![Bucket memory usage](././img/bucket_memory.png)

*This bucket has available memory, and shows no out-of-memory errors.*

Couchbase persists in-memory items to disk. This graph shows the number of items that have been added to the disk write queue in yellow, and the number of items that have been successfully written in blue. When Couchbase is able to keep up with disk writes, these metrics are equal and the graph is green. When the disk queue is filling faster than it can be drained, this graph shows yellow areas.

![Bucket write queue](././img/bucket_write_queue.png)

*This bucket is keeping up with disk writes: the number of items added to the queue is about equal to the number of items successfully written to disk.*

## METRICS

Metrics that are categorized as
[container/host](https://docs.signalfx.com/en/latest/admin-guide/usage.html#about-custom-bundled-and-high-resolution-metrics) (*default*) are ***in bold and italics*** in the list below.

These are the metrics available for this integration.

#### Group bucket
All of the following metrics are part of the `bucket` metric group. All of
the non-default metrics below can be turned on by adding `bucket` to the
monitor config option `extraGroups`:
 - `gauge.bucket.basic.dataUsed` (*gauge*)<br>    Size of user data within buckets of the specified state that are resident in RAM (%)
 - `gauge.bucket.basic.diskFetches` (*gauge*)<br>    Number of disk fetches
 - ***`gauge.bucket.basic.diskUsed`*** (*gauge*)<br>    Amount of disk used (bytes)
 - ***`gauge.bucket.basic.itemCount`*** (*gauge*)<br>    Number of items associated with the bucket
 - `gauge.bucket.basic.memUsed` (*gauge*)<br>    Amount of memory used by the bucket (bytes)
 - ***`gauge.bucket.basic.opsPerSec`*** (*gauge*)<br>    Number of operations per second
 - ***`gauge.bucket.basic.quotaPercentUsed`*** (*gauge*)<br>    Percentage of RAM used (for active objects) against the configure bucket size (%)
 - `gauge.bucket.hot_keys.0` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.1` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.10` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.2` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.3` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.4` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.5` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.6` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.7` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.8` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.hot_keys.9` (*gauge*)<br>    One of the most used keys in this bucket
 - `gauge.bucket.op.avg_bg_wait_time` (*gauge*)<br>    Average background wait time
 - `gauge.bucket.op.avg_disk_commit_time` (*gauge*)<br>    Average disk commit time
 - `gauge.bucket.op.avg_disk_update_time` (*gauge*)<br>    Average disk update time
 - `gauge.bucket.op.bg_wait_count` (*gauge*)<br>
 - `gauge.bucket.op.bg_wait_total` (*gauge*)<br>    The total background wait time
 - `gauge.bucket.op.bytes_read` (*gauge*)<br>    Number of bytes read
 - `gauge.bucket.op.bytes_written` (*gauge*)<br>    Number of bytes written
 - `gauge.bucket.op.cas_badval` (*gauge*)<br>    Number of CAS operations per second using an incorrect CAS ID for data that this bucket contains
 - `gauge.bucket.op.cas_hits` (*gauge*)<br>    Number of CAS operations per second for data that this bucket contains
 - `gauge.bucket.op.cas_misses` (*gauge*)<br>    Number of CAS operations per second for data that this bucket does not contain
 - ***`gauge.bucket.op.cmd_get`*** (*gauge*)<br>    requested objects
 - `gauge.bucket.op.cmd_set` (*gauge*)<br>    Number of writes (set operations) per second to this bucket
 - `gauge.bucket.op.couch_docs_actual_disk_size` (*gauge*)<br>    The size of the couchbase docs on disk
 - `gauge.bucket.op.couch_docs_data_size` (*gauge*)<br>    The size of active data in this bucket
 - `gauge.bucket.op.couch_docs_disk_size` (*gauge*)<br>    Couch docs total size in bytes
 - ***`gauge.bucket.op.couch_docs_fragmentation`*** (*gauge*)<br>    Percent fragmentation of documents in this bucket
 - `gauge.bucket.op.couch_spatial_data_size` (*gauge*)<br>    The size of object data for spatial views
 - `gauge.bucket.op.couch_spatial_disk_size` (*gauge*)<br>    The amount of disk space occupied by spatial views
 - `gauge.bucket.op.couch_spatial_ops` (*gauge*)<br>    Number of spatial operations
 - `gauge.bucket.op.couch_total_disk_size` (*gauge*)<br>    The total size on disk of all data and view files for this bucket
 - `gauge.bucket.op.couch_views_actual_disk_size` (*gauge*)<br>    The size of all active items in all the indexes for this bucket on disk
 - `gauge.bucket.op.couch_views_data_size` (*gauge*)<br>    The size of object data for views
 - `gauge.bucket.op.couch_views_disk_size` (*gauge*)<br>    The amount of disk space occupied by views
 - `gauge.bucket.op.couch_views_fragmentation` (*gauge*)<br>    How much fragmented data there is to be compacted compared to real data for the view index files in this bucket
 - ***`gauge.bucket.op.couch_views_ops`*** (*gauge*)<br>    view operations per second
 - `gauge.bucket.op.cpu_idle_ms` (*gauge*)<br>    CPU Idle milliseconds
 - `gauge.bucket.op.cpu_utilization_rate` (*gauge*)<br>    Percentage of CPU in use across all available cores on this server
 - ***`gauge.bucket.op.curr_connections`*** (*gauge*)<br>    open connection per bucket
 - `gauge.bucket.op.curr_items` (*gauge*)<br>    total number of stored items per bucket
 - `gauge.bucket.op.curr_items_tot` (*gauge*)<br>    Total number of items
 - `gauge.bucket.op.decr_hits` (*gauge*)<br>    Number of decrement hits
 - `gauge.bucket.op.decr_misses` (*gauge*)<br>    Number of decrement misses
 - `gauge.bucket.op.delete_hits` (*gauge*)<br>    Number of delete hits
 - `gauge.bucket.op.delete_misses` (*gauge*)<br>    Number of delete misses
 - `gauge.bucket.op.disk_commit_count` (*gauge*)<br>    Number of disk commits
 - `gauge.bucket.op.disk_commit_total` (*gauge*)<br>    Total number of disk commits
 - `gauge.bucket.op.disk_update_count` (*gauge*)<br>    Number of disk updates
 - `gauge.bucket.op.disk_update_total` (*gauge*)<br>    Total number of disk updates
 - `gauge.bucket.op.disk_write_queue` (*gauge*)<br>    number of items waiting to be written to disk
 - ***`gauge.bucket.op.ep_bg_fetched`*** (*gauge*)<br>    number of items fetched from disk
 - ***`gauge.bucket.op.ep_cache_miss_rate`*** (*gauge*)<br>    ratio of requested objects found in cache vs retrieved from disk
 - `gauge.bucket.op.ep_dcp_2i_backoff` (*gauge*)<br>    Number of backoffs for indexes DCP connections
 - `gauge.bucket.op.ep_dcp_2i_count` (*gauge*)<br>    Number of indexes DCP connections
 - `gauge.bucket.op.ep_dcp_2i_items_remaining` (*gauge*)<br>    Number of indexes items remaining to be sent
 - `gauge.bucket.op.ep_dcp_2i_items_sent` (*gauge*)<br>    Number of indexes items sent
 - `gauge.bucket.op.ep_dcp_2i_producer_count` (*gauge*)<br>    Number of indexes producers
 - `gauge.bucket.op.ep_dcp_2i_total_backlog_size` (*gauge*)<br>    Number of items in dcp backlog
 - `gauge.bucket.op.ep_dcp_2i_total_bytes` (*gauge*)<br>    Number bytes per second being sent for indexes DCP connections
 - `gauge.bucket.op.ep_dcp_other_backoff` (*gauge*)<br>    Number of backoffs for other DCP connections
 - `gauge.bucket.op.ep_dcp_other_count` (*gauge*)<br>    Number of other DCP connections
 - `gauge.bucket.op.ep_dcp_other_items_remaining` (*gauge*)<br>    Number of other items remaining to be sent
 - `gauge.bucket.op.ep_dcp_other_items_sent` (*gauge*)<br>    Number of other items sent
 - `gauge.bucket.op.ep_dcp_other_producer_count` (*gauge*)<br>    Number of other producers
 - `gauge.bucket.op.ep_dcp_other_total_backlog_size` (*gauge*)<br>    Number of remaining items for replication
 - `gauge.bucket.op.ep_dcp_other_total_bytes` (*gauge*)<br>    Number bytes per second being sent for other DCP connections
 - `gauge.bucket.op.ep_dcp_replica_backoff` (*gauge*)<br>    Number of backoffs for replica DCP connections
 - `gauge.bucket.op.ep_dcp_replica_count` (*gauge*)<br>    Number of replica DCP connections
 - `gauge.bucket.op.ep_dcp_replica_items_remaining` (*gauge*)<br>    Number of replica items remaining to be sent
 - `gauge.bucket.op.ep_dcp_replica_items_sent` (*gauge*)<br>    Number of replica items sent
 - `gauge.bucket.op.ep_dcp_replica_producer_count` (*gauge*)<br>    Number of replica producers
 - `gauge.bucket.op.ep_dcp_replica_total_backlog_size` (*gauge*)<br>    Number of remaining items for replication
 - `gauge.bucket.op.ep_dcp_replica_total_bytes` (*gauge*)<br>    Number bytes per second being sent for replica DCP connections
 - `gauge.bucket.op.ep_dcp_views_backoff` (*gauge*)<br>    Number of backoffs for views DCP connections
 - `gauge.bucket.op.ep_dcp_views_count` (*gauge*)<br>    Number of views DCP connections
 - `gauge.bucket.op.ep_dcp_views_items_remaining` (*gauge*)<br>    Number of views items remaining to be sent
 - `gauge.bucket.op.ep_dcp_views_items_sent` (*gauge*)<br>    Number of view items sent
 - `gauge.bucket.op.ep_dcp_views_producer_count` (*gauge*)<br>    Number of views producers
 - `gauge.bucket.op.ep_dcp_views_total_bytes` (*gauge*)<br>    Number bytes per second being sent for views DCP connections
 - `gauge.bucket.op.ep_dcp_xdcr_backoff` (*gauge*)<br>    Number of backoffs for xdcr DCP connections
 - `gauge.bucket.op.ep_dcp_xdcr_count` (*gauge*)<br>    Number of xdcr DCP connections
 - `gauge.bucket.op.ep_dcp_xdcr_items_remaining` (*gauge*)<br>    Number of xdcr items remaining to be sent
 - `gauge.bucket.op.ep_dcp_xdcr_items_sent` (*gauge*)<br>    Number of xdcr items sent
 - `gauge.bucket.op.ep_dcp_xdcr_producer_count` (*gauge*)<br>    Number of xdcr producers
 - `gauge.bucket.op.ep_dcp_xdcr_total_backlog_size` (*gauge*)<br>    Number of items waiting replication
 - `gauge.bucket.op.ep_dcp_xdcr_total_bytes` (*gauge*)<br>    Number bytes per second being sent for xdcr DCP connections
 - ***`gauge.bucket.op.ep_diskqueue_drain`*** (*gauge*)<br>    items removed from disk queue
 - ***`gauge.bucket.op.ep_diskqueue_fill`*** (*gauge*)<br>    enqueued items on disk queue
 - `gauge.bucket.op.ep_diskqueue_items` (*gauge*)<br>    The number of items waiting to be written to disk for this bucket for this state
 - `gauge.bucket.op.ep_flusher_todo` (*gauge*)<br>    Number of items currently being written
 - `gauge.bucket.op.ep_item_commit_failed` (*gauge*)<br>    Number of times a transaction failed to commit due to storage errors
 - `gauge.bucket.op.ep_kv_size` (*gauge*)<br>    Total amount of user data cached in RAM in this bucket
 - `gauge.bucket.op.ep_max_size` (*gauge*)<br>    The maximum amount of memory this bucket can use
 - ***`gauge.bucket.op.ep_mem_high_wat`*** (*gauge*)<br>    memory high water mark - point at which active objects begin to be ejected from bucket
 - `gauge.bucket.op.ep_mem_low_wat` (*gauge*)<br>    memory low water mark
 - `gauge.bucket.op.ep_meta_data_memory` (*gauge*)<br>    Total amount of item  metadata consuming RAM in this bucket
 - `gauge.bucket.op.ep_num_non_resident` (*gauge*)<br>    Number of non-resident items
 - `gauge.bucket.op.ep_num_ops_del_meta` (*gauge*)<br>    Number of delete operations per second for this bucket as the target for XDCR
 - `gauge.bucket.op.ep_num_ops_del_ret_meta` (*gauge*)<br>    Number of delRetMeta operations per second for this bucket as the target for XDCR
 - `gauge.bucket.op.ep_num_ops_get_meta` (*gauge*)<br>    Number of read operations per second for this bucket as the target for XDCR
 - `gauge.bucket.op.ep_num_ops_set_meta` (*gauge*)<br>    Number of set operations per second for this bucket as the target for XDCR
 - `gauge.bucket.op.ep_num_ops_set_ret_meta` (*gauge*)<br>    Number of setRetMeta operations per second for this bucket as the target for XDCR
 - ***`gauge.bucket.op.ep_num_value_ejects`*** (*gauge*)<br>    number of objects ejected out of the bucket
 - ***`gauge.bucket.op.ep_oom_errors`*** (*gauge*)<br>    request rejected - bucket is at quota, panic
 - `gauge.bucket.op.ep_ops_create` (*gauge*)<br>    Total number of new items being inserted into this bucket
 - `gauge.bucket.op.ep_ops_update` (*gauge*)<br>    Number of update operations
 - `gauge.bucket.op.ep_overhead` (*gauge*)<br>    Extra memory used by transient data like persistence queues or checkpoints
 - ***`gauge.bucket.op.ep_queue_size`*** (*gauge*)<br>    number of items queued for storage
 - `gauge.bucket.op.ep_resident_items_rate` (*gauge*)<br>    Number of resident items
 - `gauge.bucket.op.ep_tap_rebalance_count` (*gauge*)<br>    Number of internal rebalancing TAP queues in this bucket
 - `gauge.bucket.op.ep_tap_rebalance_qlen` (*gauge*)<br>    Number of items in the rebalance TAP queues in this bucket
 - `gauge.bucket.op.ep_tap_rebalance_queue_backfillremaining` (*gauge*)<br>    Number of items in the backfill queues of rebalancing TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_rebalance_queue_backoff` (*gauge*)<br>    Number of back-offs received per second while sending data over rebalancing TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_rebalance_queue_drain` (*gauge*)<br>    Number of items per second being sent over rebalancing TAP connections to this bucket, i.e. removed from queue.
 - `gauge.bucket.op.ep_tap_rebalance_queue_itemondisk` (*gauge*)<br>    Number of items still on disk to be loaded for rebalancing TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_rebalance_total_backlog_size` (*gauge*)<br>    Number of items remaining for replication
 - `gauge.bucket.op.ep_tap_replica_count` (*gauge*)<br>    Number of internal replication TAP queues in this bucket
 - `gauge.bucket.op.ep_tap_replica_qlen` (*gauge*)<br>    Number of items in the replication TAP queues in this bucket
 - `gauge.bucket.op.ep_tap_replica_queue_backoff` (*gauge*)<br>    Number of back-offs received per second while sending data over replication TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_replica_queue_drain` (*gauge*)<br>    Number of items per second being sent over replication TAP connections to this bucket, i.e. removed from queue
 - `gauge.bucket.op.ep_tap_replica_queue_itemondisk` (*gauge*)<br>    Number of items still on disk to be loaded for replication TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_replica_total_backlog_size` (*gauge*)<br>    Number of remaining items for replication
 - `gauge.bucket.op.ep_tap_total_count` (*gauge*)<br>    Total number of internal TAP queues in this bucket
 - `gauge.bucket.op.ep_tap_total_qlen` (*gauge*)<br>    Total number of items in TAP queues in this bucket
 - `gauge.bucket.op.ep_tap_total_queue_backfillremaining` (*gauge*)<br>    Total number of items in the backfill queues of TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_total_queue_backoff` (*gauge*)<br>    Total number of back-offs received per second while sending data over TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_total_queue_drain` (*gauge*)<br>    Total number of items per second being sent over TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_total_queue_fill` (*gauge*)<br>    Total enqueued items in the queue.
 - `gauge.bucket.op.ep_tap_total_queue_itemondisk` (*gauge*)<br>    The number of items waiting to be written to disk for this bucket for this state.
 - `gauge.bucket.op.ep_tap_total_total_backlog_size` (*gauge*)<br>    Number of remaining items for replication
 - `gauge.bucket.op.ep_tap_user_count` (*gauge*)<br>    Number of internal user TAP queues in this bucket
 - `gauge.bucket.op.ep_tap_user_qlen` (*gauge*)<br>    Number of items in user TAP queues in this bucket
 - `gauge.bucket.op.ep_tap_user_queue_backfillremaining` (*gauge*)<br>    Number of items in the backfill queues of user TAP connections to this bucket.
 - `gauge.bucket.op.ep_tap_user_queue_backoff` (*gauge*)<br>    Number of back-offs received per second while sending data over user TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_user_queue_drain` (*gauge*)<br>    Number of items per second being sent over user TAP connections to this bucket, i.e. removed from queue
 - `gauge.bucket.op.ep_tap_user_queue_fill` (*gauge*)<br>    Number of items per second being put on the user TAP queues
 - `gauge.bucket.op.ep_tap_user_queue_itemondisk` (*gauge*)<br>    Number of items still on disk to be loaded for client TAP connections to this bucket
 - `gauge.bucket.op.ep_tap_user_total_backlog_size` (*gauge*)<br>    Number of remaining items for replication
 - ***`gauge.bucket.op.ep_tmp_oom_errors`*** (*gauge*)<br>    request rejected - couchbase is making room by ejecting objects, try again later
 - `gauge.bucket.op.ep_vb_total` (*gauge*)<br>    Total number of vBuckets for this bucket
 - `gauge.bucket.op.evictions` (*gauge*)<br>    Number of evictions
 - `gauge.bucket.op.get_hits` (*gauge*)<br>    Number of get hits
 - `gauge.bucket.op.get_misses` (*gauge*)<br>    Number of get misses
 - `gauge.bucket.op.hibernated_requests` (*gauge*)<br>    Number of streaming requests now idle
 - `gauge.bucket.op.hibernated_waked` (*gauge*)<br>    Rate of streaming request wakeups
 - `gauge.bucket.op.hit_ratio` (*gauge*)<br>    Hit ratio.
 - `gauge.bucket.op.incr_hits` (*gauge*)<br>    Number of increment hits
 - `gauge.bucket.op.incr_misses` (*gauge*)<br>    Number of increment misses
 - `gauge.bucket.op.mem_actual_free` (*gauge*)<br>    Amount of RAM available
 - `gauge.bucket.op.mem_actual_used` (*gauge*)<br>    Used memory
 - `gauge.bucket.op.mem_free` (*gauge*)<br>    Free memory
 - `gauge.bucket.op.mem_total` (*gauge*)<br>    Total available memory
 - ***`gauge.bucket.op.mem_used`*** (*gauge*)<br>    memory used
 - `gauge.bucket.op.mem_used_sys` (*gauge*)<br>    System memory usage
 - `gauge.bucket.op.misses` (*gauge*)<br>    Total number of misses
 - `gauge.bucket.op.ops` (*gauge*)<br>    total of gets, sets, increment and decrement
 - `gauge.bucket.op.rest_requests` (*gauge*)<br>    Number of HTTP requests
 - `gauge.bucket.op.swap_total` (*gauge*)<br>    Total amount of swap available
 - `gauge.bucket.op.swap_used` (*gauge*)<br>    Amount of swap used
 - `gauge.bucket.op.vb_active_eject` (*gauge*)<br>    Number of items per second being ejected to disk from active vBuckets
 - `gauge.bucket.op.vb_active_itm_memory` (*gauge*)<br>    Amount of active user data cached in RAM in this bucket
 - `gauge.bucket.op.vb_active_meta_data_memory` (*gauge*)<br>    Amount of active item metadata consuming RAM in this bucket
 - `gauge.bucket.op.vb_active_num` (*gauge*)<br>    Number of vBuckets in the active state for this bucket
 - `gauge.bucket.op.vb_active_num_non_resident` (*gauge*)<br>    Number of non resident vBuckets in the active state for this bucket
 - `gauge.bucket.op.vb_active_ops_create` (*gauge*)<br>    New items per second being inserted into active vBuckets in this bucket
 - `gauge.bucket.op.vb_active_ops_update` (*gauge*)<br>    Number of items updated on active vBucket per second for this bucket
 - `gauge.bucket.op.vb_active_queue_age` (*gauge*)<br>    Sum of disk queue item age in milliseconds
 - `gauge.bucket.op.vb_active_queue_drain` (*gauge*)<br>    Number of active items per second being written to disk in this bucket
 - `gauge.bucket.op.vb_active_queue_fill` (*gauge*)<br>    Number of active items per second being put on the active item disk queue in this bucket
 - `gauge.bucket.op.vb_active_queue_size` (*gauge*)<br>    Number of active items waiting to be written to disk in this bucket
 - ***`gauge.bucket.op.vb_active_resident_items_ratio`*** (*gauge*)<br>    ratio of items kept in memory vs stored on disk
 - `gauge.bucket.op.vb_avg_active_queue_age` (*gauge*)<br>    Average age in seconds of active items in the active item queue for this bucket
 - `gauge.bucket.op.vb_avg_pending_queue_age` (*gauge*)<br>    Average age in seconds of pending items in the pending item queue for this bucket and should be transient during rebalancing
 - `gauge.bucket.op.vb_avg_replica_queue_age` (*gauge*)<br>    Average age in seconds of replica items in the replica item queue for this bucket
 - `gauge.bucket.op.vb_avg_total_queue_age` (*gauge*)<br>    Average age of items in the queue
 - `gauge.bucket.op.vb_pending_curr_items` (*gauge*)<br>    Number of items in pending vBuckets in this bucket and should be transient during rebalancing
 - `gauge.bucket.op.vb_pending_eject` (*gauge*)<br>    Number of items per second being ejected to disk from pending vBuckets
 - `gauge.bucket.op.vb_pending_itm_memory` (*gauge*)<br>    Amount of pending user data cached in RAM in this bucket and should be transient during rebalancing
 - `gauge.bucket.op.vb_pending_meta_data_memory` (*gauge*)<br>    Amount of pending item metadata consuming RAM in this bucket and should be transient during rebalancing
 - `gauge.bucket.op.vb_pending_num` (*gauge*)<br>    Number of pending items
 - `gauge.bucket.op.vb_pending_num_non_resident` (*gauge*)<br>    Number of non resident vBuckets in the pending state for this bucket
 - `gauge.bucket.op.vb_pending_ops_create` (*gauge*)<br>    New items per second being instead into pending vBuckets in this bucket and should be transient during rebalancing
 - `gauge.bucket.op.vb_pending_ops_update` (*gauge*)<br>    Number of items updated on pending vBucket per second for this bucket
 - `gauge.bucket.op.vb_pending_queue_age` (*gauge*)<br>    Sum of disk pending queue item age in milliseconds
 - `gauge.bucket.op.vb_pending_queue_drain` (*gauge*)<br>    Number of pending items per second being written to disk in this bucket and should be transient during rebalancing
 - `gauge.bucket.op.vb_pending_queue_fill` (*gauge*)<br>    Total enqueued pending items on disk queue
 - `gauge.bucket.op.vb_pending_queue_size` (*gauge*)<br>    Number of pending items waiting to be written to disk in this bucket and should be transient during rebalancing
 - `gauge.bucket.op.vb_pending_resident_items_ratio` (*gauge*)<br>    Number of resident pending items
 - `gauge.bucket.op.vb_replica_curr_items` (*gauge*)<br>    Number of in memory items
 - `gauge.bucket.op.vb_replica_eject` (*gauge*)<br>    Number of items per second being ejected to disk from replica vBuckets
 - `gauge.bucket.op.vb_replica_itm_memory` (*gauge*)<br>    Amount of replica user data cached in RAM in this bucket
 - `gauge.bucket.op.vb_replica_meta_data_memory` (*gauge*)<br>    Amount of replica item metadata consuming in RAM in this bucket
 - `gauge.bucket.op.vb_replica_num` (*gauge*)<br>    Number of replica vBuckets
 - `gauge.bucket.op.vb_replica_num_non_resident` (*gauge*)<br>    Number of non resident vBuckets in the replica state for this bucket
 - `gauge.bucket.op.vb_replica_ops_create` (*gauge*)<br>    Number of replica create operations
 - `gauge.bucket.op.vb_replica_ops_update` (*gauge*)<br>    Number of items updated on replica vBucket per second for this bucket
 - `gauge.bucket.op.vb_replica_queue_age` (*gauge*)<br>    Sum of disk replica queue item age in milliseconds
 - `gauge.bucket.op.vb_replica_queue_drain` (*gauge*)<br>    Total drained replica items in the queue
 - `gauge.bucket.op.vb_replica_queue_fill` (*gauge*)<br>    Number of replica items per second being put on the replica item disk queue in this bucket
 - `gauge.bucket.op.vb_replica_queue_size` (*gauge*)<br>    Number of replica items in disk queue
 - `gauge.bucket.op.vb_replica_resident_items_ratio` (*gauge*)<br>    Percentage of replica items cached in RAM in this bucket.
 - `gauge.bucket.op.vb_total_queue_age` (*gauge*)<br>    Sum of disk queue item age in milliseconds
 - `gauge.bucket.op.xdc_ops` (*gauge*)<br>    Cross datacenter replication operations per second for this bucket
 - `gauge.bucket.quota.ram` (*gauge*)<br>    Amount of RAM used by the bucket (bytes)
 - `gauge.bucket.quota.rawRAM` (*gauge*)<br>    Amount of raw RAM used by the bucket (bytes)

#### Group nodes
All of the following metrics are part of the `nodes` metric group. All of
the non-default metrics below can be turned on by adding `nodes` to the
monitor config option `extraGroups`:
 - ***`gauge.nodes.cmd_get`*** (*gauge*)<br>    Number of get commands
 - ***`gauge.nodes.couch_docs_actual_disk_size`*** (*gauge*)<br>    Amount of disk space used by Couch docs (bytes)
 - ***`gauge.nodes.couch_docs_data_size`*** (*gauge*)<br>    Data size of couch documents associated with a node (bytes)
 - `gauge.nodes.couch_spatial_data_size` (*gauge*)<br>    Size of object data for spatial views (bytes)
 - `gauge.nodes.couch_spatial_disk_size` (*gauge*)<br>    Amount of disk space occupied by spatial views, in bytes
 - `gauge.nodes.couch_views_actual_disk_size` (*gauge*)<br>    Amount of disk space occupied by Couch views (bytes)
 - `gauge.nodes.couch_views_data_size` (*gauge*)<br>    Size of object data for Couch views (bytes)
 - `gauge.nodes.curr_items` (*gauge*)<br>    Number of current items
 - ***`gauge.nodes.curr_items_tot`*** (*gauge*)<br>    Total number of items associated with node
 - ***`gauge.nodes.ep_bg_fetched`*** (*gauge*)<br>    Number of disk fetches performed since server was started
 - `gauge.nodes.get_hits` (*gauge*)<br>    Number of get hits
 - `gauge.nodes.mcdMemoryAllocated` (*gauge*)<br>    Amount of memcached memory allocated (bytes)
 - `gauge.nodes.mcdMemoryReserved` (*gauge*)<br>    Amount of memcached memory reserved (bytes)
 - ***`gauge.nodes.mem_used`*** (*gauge*)<br>    Memory used by the node (bytes)
 - `gauge.nodes.memoryFree` (*gauge*)<br>    Amount of memory free for the node (bytes)
 - `gauge.nodes.memoryTotal` (*gauge*)<br>    Total memory available to the node (bytes)
 - ***`gauge.nodes.ops`*** (*gauge*)<br>    Number of operations performed on Couchbase
 - ***`gauge.nodes.system.cpu_utilization_rate`*** (*gauge*)<br>    The CPU utilization rate (%)
 - ***`gauge.nodes.system.mem_free`*** (*gauge*)<br>    Free memory available to the node (bytes)
 - ***`gauge.nodes.system.mem_total`*** (*gauge*)<br>    Total memory available to the node (bytes)
 - ***`gauge.nodes.system.swap_total`*** (*gauge*)<br>    Total swap size allocated (bytes)
 - ***`gauge.nodes.system.swap_used`*** (*gauge*)<br>    Amount of swap space used (bytes)
 - `gauge.nodes.vb_replica_curr_items` (*gauge*)<br>    Number of items/documents that are replicas

#### Group storage
All of the following metrics are part of the `storage` metric group. All of
the non-default metrics below can be turned on by adding `storage` to the
monitor config option `extraGroups`:
 - `gauge.storage.hdd.free` (*gauge*)<br>    Free harddrive space in the cluster (bytes)
 - `gauge.storage.hdd.quotaTotal` (*gauge*)<br>    Harddrive quota total for the cluster (bytes)
 - `gauge.storage.hdd.total` (*gauge*)<br>    Total harddrive space available to cluster (bytes)
 - `gauge.storage.hdd.used` (*gauge*)<br>    Harddrive space used by the cluster (bytes)
 - `gauge.storage.hdd.usedByData` (*gauge*)<br>    Harddrive use by the data in the cluster(bytes)
 - `gauge.storage.ram.quotaTotal` (*gauge*)<br>    Ram quota total for the cluster (bytes)
 - `gauge.storage.ram.quotaTotalPerNode` (*gauge*)<br>    Ram quota total per node (bytes)
 - `gauge.storage.ram.quotaUsed` (*gauge*)<br>    Ram quota used by the cluster (bytes)
 - `gauge.storage.ram.quotaUsedPerNode` (*gauge*)<br>    Ram quota used per node (bytes)
 - `gauge.storage.ram.total` (*gauge*)<br>    Total ram available to cluster (bytes)
 - `gauge.storage.ram.used` (*gauge*)<br>    RAM used by the cluster (bytes)
 - `gauge.storage.ram.usedByData` (*gauge*)<br>    Ram used by the data in the cluster (bytes)

### Non-default metrics (version 4.7.0+)

**The following information applies to the agent version 4.7.0+ that has
`enableBuiltInFiltering: true` set on the top level of the agent config.**

To generate metrics that are not _default_, you add them in the
generic monitor-level `extraMetrics` config option.  Metrics that are derived
from specific configuration options that do not appear in the above list of
metrics do not need to be added to `extraMetrics`.

To see a list of metrics that will be generated, you can run `agent-status
monitors` after configuring this monitor in a running agent instance.

### Legacy non-default metrics (version < 4.7.0)

**The following information only applies to agent versions older than 4.7.0. If
you have a newer agent and have set `enableBuiltInFiltering: true` at the top
level of your agent config, see the section above. See upgrade instructions in
[Old-style inclusion list filtering](https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/../legacy-filtering.md#old-style-inclusion-list-filtering).**

If you have a reference to the `whitelist.json` in your agent's top-level
`metricsToExclude` config option, and you want to emit metrics that are not in
that allow list, then you need to add an item to the top-level
`metricsToInclude` config option to override that allow list (see [Inclusion
filtering](https://github.com/signalfx/signalfx-agent/tree/master/docs/monitors/../legacy-filtering.md#inclusion-filtering).  Or you can just
copy the whitelist.json, modify it, and reference that in `metricsToExclude`.

#### LICENSE

This integration is released under the Apache 2.0 license. See [LICENSE](./LICENSE) for more details.
